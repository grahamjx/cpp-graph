### Design Write-Up
Following the guidelines of the assignment, I created a class "graph" that's acts as a manager of my data structure, a adjacency list. For my implementation, I also created a struct which is used for the data containing each topic (vertex) entered by the user.
The graph class lies at the center of my implementation of the Graph ADT and its public process are limited to adding a vertex, adding an edge, retrieving vertices adjacent to a chosen vertex and displaying information using a depth-first traversal method. To meet the requirements of the assignment, some of my public member functions utilize recursion to carry out operations on the adjacency list.

For adding a vertex / adding an edge to the graph, I implemented the processes iteratively. To accomplish this, I first developed a simple search function that would search through the adjacency list looking for a matching vertex. If a match was found, then the function would return the position (index) where the item was found in the adjacency list. By utilizing this function, adding topics (vertices) or setting dependencies (edges) could be carried out quickly and efficiently. Adding a vertex was as simple as first checking to make sure the topic didn't already exist and then adding the topic to the next element in the array. Adding an edge was also carried out in a similar manner by first checking to make sure the purposed topic and dependency existed, and then utilizing the returned position to carry out the adding of an edge node to the vertex's edge list. Utilizing the power of quick access provided by an array, these process are carried out with great run-time efficiency. I opted not to implement these process using recursion since, unlike in past assignments, the adjacency list is an array of vertices (nodes). When attempting to implement the function recursively, I struggled to find a way for the recursion to stop. This is a pretty straight forward process when using an array of pointers, but not when dealing with an array of nodes. In turn, I feel like both adding a vertex and adding an edge recursively would actually be more inefficient. It would require an additional private function, additional variables, more function arguments, among other things. By carrying out a few of my process iteratively, the ability to utilize the fast access of an array was better harnessed and fell more inline with its run-time process.

For retrieving adjacent vertices and displaying information using a depth-first traversal, I implemented the processes recursively. To accomplish this, I created two public member functions that act as "wrapper" functions which handle some basic operations. Both functions still utilize the search function to make sure that the requested topic entered by the user exists. I designed the functions in this way to ensure that the purposed topic was found before the recursive counterpart of the operation was called. In addition, being able to utilize the returned position from search simplified the number/type of arguments required to carry out the recursion. Overall, the use of recursion on these two operations was a benefit. One could argue that the retrieve adjacent process, which essentially traverses a linear linked list, could be done just as effectively in a loop. However, the use of recursion on the depth-first traversal greatly reduces the number of operations that would be required if done iteratively. In general, I feel like the use of recursion for these two operations lead to greater run-time efficiency and memory overhead compared to their iterative counterparts.

For my implementation of the adjacency list, I created two separate node structures. The first one (vertex_node) holds the data for each topic entered by the user. The node also contains a edge_node head pointer and a flag variable. The edge_node head pointer represents a particular vertex's edge list. An edge list for this assignment essentially represents dependencies that the chosen topic (vertex) has. For example, if a person wants to learn about Linear Linked Lists, understanding of the topic would require knowledge (dependency) of operations such as "new" and "delete". My graph implementation works by letting the user enter a variety of topics and then set the dependencies associated with each. The second node (edge_node) is made up a vertex variable and a next pointer. When a user sets a dependency, an new edge node gets added to that topics edge list. The vertex variable for that edge node will then be set to the topic which they selected as a dependency. For example, if the user enters "LLL" for the topic and then "Pointer" as the dependency, the vertex variable in the edge node would correspond to the position (index) in which "Pointer" resides in the adjacency list. I implemented the edge node in this way in order to further utilize the fast access provided by an array and remove some of the hassle and/or complication when dealing with another pointer variable.

One particular source of inefficiency in my project, is that I still use a separate struct in which to manage my data. This makes little sense for this implementation since the vertex information only contains one field, a topic. However, I found that keeping the data as an object separate from the vertex_node made implementing my retrieve function easier since I could simply copy data objects out of the adjacent list into my results array. This was simpler and easier to implement for me in comparison to using an array of character arrays instead. Of course, the use of a separate struct to manage my data does add additional code and potential run-time inefficiency. In retrospect, I can appreciate the flexibility that a separate struct for my data provides, especially in the event that more than just a single array of characters wanted to be stored inside a vertex, but continuing its use in my implementation only bloated the overall process and lead to additional unneeded operations over time.

As far using a adjacency list as the data structure in my implementation, I found it was decent choice. The ability to have fast access to array elements is such a huge benefit on nearly every operation. Adding vertices, adding edges and searching for a matching item, are just some of the process that really shine through in terms of efficiency when using this data structure. I felt that using an array of nodes instead of an array of pointers was actually more challenging to manage. One of the great things about pointers is that a check on the variable is as simple as seeing if the pointer is set to null. One possible alternative to using an adjacency list for this assignment would be to use a flexible array. Each vertex could be set to the head pointer in each array element. When a dependency was set, a new node could be added at the end of the LLL for that particular vertex. By adding at the end for each dependency, would eliminate the need for a traversal if using a tail pointer and still provide the benefit of having a simple check to see if a particular index is null.

If I had more time to work on this project, I would like to further experiment with different traversal algorithms such as incorporating a breadth-first traversal as well. I also would like to test out different ways the user could add topics and set dependencies in a more visual way. Possibly by displaying a list of topics and let them pick a topic and a dependency to go with it. The client side of the program just takes a lot of input and dependency setting before you get a good grasp of how the graph might look.
